[{"lang":"en","lvl2":"Usage with GraalVM\nArthur Integration","text":"yupiik-logging-jul will set itself as JUL LogManager during the build time so ensure it does not compete with another logging framework.\nOnce done you can run with no logging configuration or override it through the standard java.util.logging.config.file system property.\nTo use this module with Arthur you can use this configuration:","title":"GraalVM","url":"//www.yupiik.io/yupiik-logging/graalvm-integration.html"},{"lang":"en","lvl2":"Use globally\nConfiguration\nStandard handler\nFile Handler\nAsync handler\nPattern formatter\nJSON formatter\nSample Configuration Files","lvl3":"Duration Format","text":"\nJava Util Logging integration is provided as part of the artifact:\nConfiguration is close to default JUL one with small differences:\nhandlers don't need to configure themselves in their constructor or so for common properties (formatter, level, ...), the framework does it automatically\nInlineFormatter and JsonFormatter support aliases (reflection free instantiation) with inline and json you can use in the configuration\nio.yupiik.logging.jul.handler.StandardHandler enables to log on stdout and stderr. For all level from finest/debug to info it will go on stdout and others (warnings, errors/severes) will go on stderr.\nIt can be configured with the std or standard alias too.\nThere is also its companion stdout or io.yupiik.logging.jul.handler.StdoutHandler which only outputs on stdout.\nA io.yupiik.logging.jul.handler.LocalFileHandler is also provided to be able to log in a file and rotate the log file. Indeed you can use JVM FileHandler but this one is a bit more powerful in practise if you don't run in a container and can't use a docker logging driver or equivalent.\nHere is its configuration - all are prefixed with io.yupiik.logging.jul.handler.LocalFileHandler. and the standard configuration (encoding, level, ...) is still supported even if not listed.\n$/logs/logs.%s.%03d.log\n$/logs/archives/\nThe format for the String to be parsed is PnDTnHnMn.nS where nD means n number of Days, nH means n number of Hours, nM means n number of Minutes, nS means n number of Seconds and T is a prefix that must be used before the part consisting of nHnMn.nS.\nio.yupiik.logging.jul.handler.AsyncHandler enables to handle asynchronously in a background thread log events (LogRecord).\nio.yupiik.logging.jul.handler.AsyncHandler.delegate.class enables to configure the delegate class name.\nThe properties like io.yupiik.logging.jul.handler.AsyncHandler.formatter etc are forwarded to the delegate if set - and generally override the default ones.\nlogging asynchronously means you are loosing the context related to threads - if you are using a ThreadLocal and not yet a ScopedValue in a 100% virtual thread based application. For that purposes we enable the formatters and delegate handler to implement io.yupiik.logging.jul.api.RecordFreezer which will take the LogRecord when emitted, convert it to a new LogRecord (RecordFreezer.FrozenLogRecord is a default implementation) which is initialized at that moment and just read when emitted to the delegating handler to have the proper informations. This is often used for custom JSON entries mapper (similar to MDC/NDC) when the implementation relies on ThreadLocal.\nThe library also provides a pattern formatter. It does not use String.format as SimpleFormatter does and can be configured either with io.yupiik.logging.jul.formatter.PatternFormatter.pattern property or passing the pattern to the formatter alias (reflection free mode): pattern(<pattern to use>). Its syntax uses % to mark elements of the log record. Here is the list:\nPattern example value: %d [%l][%c][%C][%M] %m%x%n, it will output lines like 1970-01-01T00:00:00Z [INFO][the.logger][the.source][the.method] test message\\n.\nJSON formatter relies on JSON-B until 1.0.2, JSON-P starting with 1.0.3 and no dependency starting with 1.0.8 so ensure to add the related dependencies. It can be done with this list for example:\nthe JSON formatter can be configured passing json(useUUID=[false|true],formatMessage=[true|false],customEntriesMapper=<fqn of a Function<LogRecord, Map<String, String>>>) value instead of just json. All configuration being optional.formatMessage enables to skip the message formatting when your application does not rely on it - faster and uses less the CPU, useUUID enables to force an unique ID in the record.customEntriesMapper enables to pass a function taking the log record and converting it to a map of data to append to the json object (must be String key/values).\nAs with native JUL LogManager, you can configure the runtime logging with the following system property: -Djava.util.logging.config.file=<path to config file>.\ndon't forget -Djava.util.logging.manager=io.yupiik.logging.jul.YupiikLogManager too.\nHere is a sample configuration switching to JSON logging:\nThe same configuration for a standard inline logging (text style) but tuning the log level:\nHere is a configuration using a pattern:\nAnd finally a configuration using file output instead of standard one:\nyou can set all properties as system properties and also environment variables (in uppercase and dots replaced by underscores).","title":"JUL Integration","url":"//www.yupiik.io/yupiik-logging/jul-integration.html"},{"lang":"en","text":"This project provides some logging utilities.\nIt mainly provides a Java Util Logging (JUL) LogManager which is graal friendly - you can reconfigure your JUL loggers at runtime - plus some utilities like mor advanced formatters or handlers.\nFor more information, read JUL Integration documentation.","title":"Overview","url":"//www.yupiik.io/yupiik-logging/overview.html"},{"lang":"en","text":"","title":"Yupiik Logging documentation","url":"//www.yupiik.io/yupiik-logging/index.html"}]