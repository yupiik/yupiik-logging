[{"lang":"en","lvl2":"Usage with GraalVM\nArthur Integration","text":"Yupiik Logging JUL is integrated with GraalVM native image feature. To enable it you must set in native-image command line the following system property: -Djava.util.logging.manager=io.yupiik.logging.jul.YupiikLogManager. Other required setup is done in the jar and automatically picked up by native-image.\nyupiik-logging-jul will set itself as JUL LogManager during the build time so ensure it does not compete with another logging framework.\nOnce done you can run with no logging configuration or override it through the standard java.util.logging.config.file system property.\nTo use this module with Arthur you can use this configuration:","title":"GraalVM","url":"//www.yupiik.io/yupiik-logging/graalvm-integration.html"},{"lang":"en","lvl2":"Use globally\nConfiguration\nStandard handler\nFile Handler\nPattern formatter\nJSON formatter\nSample Configuration Files","text":"Java Util Logging integration is provided as part of the artifact:\nConfiguration is close to default JUL one with small differences:\nhandlers don’t need to configure themselves in their constructor or so for common properties (formatter, level, …), the framework does it automatically\nInlineFormatter and JsonFormatter support aliases (reflection free instantiation) with inline and json you can use in the configuration\nio.yupiik.logging.jul.handler.StandardHandler enables to log on stdout and stderr. For all level from finest/debug to info it will go on stdout and others (warnings, errors/severes) will go on stderr.\nIt can be configured with the std or standard alias too.\nThere is also its companion stdout or io.yupiik.logging.jul.handler.StdoutHandler which only outputs on stdout.\nA io.yupiik.logging.jul.handler.LocalFileHandler is also provided to be able to log in a file and rotate the log file. Indeed you can use JVM FileHandler but this one is a bit more powerful in practise if you don’t run in a container and can’t use a docker logging driver or equivalent.\nHere is its configuration - all are prefixed with io.yupiik.logging.jul.handler.LocalFileHandler. and the standard configuration (encoding, level, …) is still supported even if not listed.\nName\nDefault Value\nDescription\nfilenamePattern\n${application.base}/logs/logs.%s.%03d.log\nwhere log files are created, it uses String.format() and gives you the date and file number - in this order. If you replace %s by %sH you will append the hour in the filename. %sHm adds the minutes (a more precise pattern is not needed nor recommended).\nnoRotation\nfalse\nif true, once a log file is opened, it is kept for the life of the process.\noverwrite\nif true, existing files are reused.\ntruncateIfExists\nif true, opening a file is not in append mode (previous content is erased).\nlimit\n10 Megabytes\nlimit size indicating the file should be rotated - in long format\ndateCheckInterval\n5 seconds\nhow often the date should be computed to rotate the file (don’t do it each time for performances reason, means you can get few records of next day in a file name with current day). In java Duration format (ex: PT5S).\nbufferSize\n-1\nif positive the in memory buffer used to store data before flushing them to the disk (in bytes)\narchiveDirectory\n${application.base}/logs/archives/\nwhere compressed logs are put.\narchiveFormat\ngzip\nzip or gzip.\narchiveOlderThan\nhow many days files are kept before being compressed\npurgeOlderThan\nhow many days files are kept before being deleted, note: it applies on archives and not log files so 2 days of archiving and 3 days of purge makes it deleted after 5 days.\ncompressionLevel\nIn case of zip archiving the zip compression level (-1 for off or 0-9).\nmaxArchives\nMax number of archives (zip/gzip) to keep, ignored if negative (you can review io.yupiik.logging.jul.handler.LocalFileHandlerTest.purgeMaxArchive for some sample configuration).\nThe library also provides a pattern formatter. It does not use String.format as SimpleFormatter does and can be configured either with io.yupiik.logging.jul.formatter.PatternFormatter.pattern property or passing the pattern to the formatter alias (reflection free mode): pattern(<pattern to use>). Its syntax uses % to mark elements of the log record. Here is the list:\n%%\nEscapes % character.\n%n\nEnd of line.\n%l or %level\nLog record level.\n%m or %message\nLog record message.\n%c or %logger\nLogger name.\n%C or %class\nClass name if exists or empty.\n%M or %method\nMethod name if exists or empty.\n%d or %date\nThe instant value. Note it can be followed by a date time formatter pattern between braces.\n%x or %exception\nThe exception. It will be preceeded by a new line if existing to ensure it integrates well in log output.\n%T or %threadId\nThread ID.\n%t or %thread or %threadName\nThread name - only works in synchronous mode.\n%r\nDuration (in ms) since the startup of the application (creating of the pattern formatter actually).\n%uuid\nRandom UUID.\nPattern example value: %d [%l][%c][%C][%M] %m%x%n, it will output lines like 1970-01-01T00:00:00Z [INFO][the.logger][the.source][the.method] test message\\n.\nJSON formatter relies on JSON-B until 1.0.2, JSON-P starting with 1.0.3 and no dependency starting with 1.0.8 so ensure to add the related dependencies. It can be done with this list for example:\nthe JSON formatter can be configured passing json(useUUID=[false|true],formatMessage=[true|false],customEntriesMapper=<fqn of a Function<LogRecord, Map<String, String>>>) value instead of just json. All configuration being optional. formatMessage enables to skip the message formatting when your application does not rely on it - faster and uses less the CPU, useUUID enables to force an unique ID in the record. customEntriesMapper enables to pass a function taking the log record and converting it to a map of data to append to the json object (must be String key/values).\nAs with native JUL LogManager, you can configure the runtime logging with the following system property: -Djava.util.logging.config.file=<path to config file>.\ndon’t forget -Djava.util.logging.manager=io.yupiik.logging.jul.YupiikLogManager too.\nHere is a sample configuration switching to JSON logging:\nThe same configuration for a standard inline logging (text style) but tuning the log level:\nHere is a configuration using a pattern:\nAnd finally a configuration using file output instead of standard one:\nyou can set all properties as system properties and also environment variables (in uppercase and dots replaced by underscores).","title":"JUL Integration","url":"//www.yupiik.io/yupiik-logging/jul-integration.html"},{"lang":"en","text":"This project provides some logging utilities.\nIt mainly provides a Java Util Logging (JUL) LogManager which is graal friendly - you can reconfigure your JUL loggers at runtime - plus some utilities like mor advanced formatters or handlers.\nFor more information, read JUL Integration documentation.","title":"Overview","url":"//www.yupiik.io/yupiik-logging/overview.html"},{"lang":"en","text":"","title":"Yupiik Logging documentation","url":"//www.yupiik.io/yupiik-logging/index.html"}]